#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>
#include <signal.h>
#include <stdint.h>
#include <elf.h>

Elf32_Ehdr *ehdr;
Elf32_Phdr *phdr;
int fd;
int page_faults = 0;
int page_allocations = 0;
int internal_fragmentation_kb = 0;

typedef int (*functocallfib)();

void page_fault_handler(int signo, siginfo_t *si, void *context)
{
    void *fault_address = si->si_addr;
    int page_size = getpagesize();
    void *page_start = (void *)((uintptr_t)fault_address & ~(page_size - 1));

    // Find the program header that contains the faulting address
    // Note: You may need to use lseek64 instead of lseek if you are on a 64-bit system
    Elf32_Phdr *target_phdr = NULL;
    for (int i = 0; i < ehdr->e_phnum; i++)
    {
        if ((uintptr_t)fault_address >= phdr[i].p_vaddr && (uintptr_t)fault_address < (phdr[i].p_vaddr + phdr[i].p_memsz))
        {
            target_phdr = &phdr[i];
            break;
        }
    }

    if (target_phdr == NULL)
    {
        perror("Segment not found for faulting address");
        exit(EXIT_FAILURE);
    }

    // Allocate memory for the page containing the faulting address
    void *allocated_page = mmap(page_start, page_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
    if (allocated_page == MAP_FAILED)
    {
        perror("mmap");
        exit(EXIT_FAILURE);
    }

    // Copy the data from the ELF file to the allocated page
    // Note: You may need to use lseek64 instead of lseek if you are on a 64-bit system
    lseek(fd, target_phdr->p_offset, SEEK_SET);
    if (read(fd, allocated_page, target_phdr->p_filesz) != target_phdr->p_filesz)
    {
        perror("read");
        exit(EXIT_FAILURE);
    }

    page_faults++;
    page_allocations++;
    internal_fragmentation_kb += (page_size - target_phdr->p_filesz) / 1024;

    // Update the instruction pointer to continue execution from the new page
    ucontext_t *ucontext = (ucontext_t *)context;

#ifdef REG_RIP
    ucontext->uc_mcontext.gregs[REG_RIP] = (greg_t)(uintptr_t)allocated_page + (uintptr_t)fault_address - (uintptr_t)page_start;
#endif

    // If REG_RIP is not defined, you may need to use an appropriate register based on your architecture.
    // For x86, you can use REG_EIP as follows:
    // ucontext->uc_mcontext.gregs[REG_EIP] = (greg_t)(uintptr_t)allocated_page + (uintptr_t)fault_address - (uintptr_t)page_start;
}

void loader_cleanup(){
 
    free(ehdr);
    free(phdr);
    close(fd);
}

void load_and_run_elf(char *exe)
{
    fd = open(exe, O_RDONLY);
    if (fd == -1){

        // printf("Error opening ELF file");
        //Exit the program this way
        perror("open");
        exit(EXIT_FAILURE);

    }
    // Read ELF header with program headers
    ehdr = (Elf32_Ehdr *)malloc(sizeof(Elf32_Ehdr));
    if (read(fd, ehdr, sizeof(Elf32_Ehdr)) != sizeof(Elf32_Ehdr) || lseek(fd, ehdr->e_phoff, SEEK_SET) != ehdr->e_phoff)
    {
        perror("read/lseek");
        close(fd);
        exit(EXIT_FAILURE);
    }

    phdr = (Elf32_Phdr *)malloc(sizeof(Elf32_Phdr) * ehdr->e_phnum);
    if (read(fd, phdr, sizeof(Elf32_Phdr) * ehdr->e_phnum) != sizeof(Elf32_Phdr) * ehdr->e_phnum)
    {
        perror("read");
        close(fd);
        exit(EXIT_FAILURE);
    }

    struct sigaction sa;
    sa.sa_sigaction = page_fault_handler;
    sa.sa_flags = SA_SIGINFO;
    sigaction(SIGSEGV, &sa, NULL);

    //printing the program headers here for debugging purposes
    // Call _start directly and handle segmentation fault if it occurs
    int result = 0;
    functocallfib _start = (functocallfib)ehdr->e_entry;
    result = _start();

    printf("Result is %d\n", result);

    printf("Total Page Faults: %d\n", page_faults);
    printf("Total Page Allocations: %d\n", page_allocations);
    printf("Total Internal Fragmentation (KB): %d\n", internal_fragmentation_kb);

    loader_cleanup();
}

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: %s \n", argv[0]);
        exit(1);
    }

    load_and_run_elf(argv[1]);

    return 0;
}
