#include "loader.h"

Elf32_Ehdr *ehdr;
Elf32_Phdr *phdr;
int fd;

static  int pagefault_occurred_count = 0;
double used,lost;
int page_size;
typedef int (*functocallfib)();
void page_allocator(void* address);
void page_fault_handler(int signo, siginfo_t *si, void *context)
{   
    void* fault_address = si->si_addr;
    printf("Segmentation fault at address: %p\n", fault_address);
    page_allocator(fault_address);
    
}
void page_allocator(void* address){
    void *vir_addr = (void *)((uintptr_t)address & ~(page_size - 1));

    
    Elf32_Phdr *target_phdr = NULL;
    for (int i = 0; i < ehdr->e_phnum; i++)
    {
        if ((uintptr_t)address >= phdr[i].p_vaddr && (uintptr_t)address < (phdr[i].p_vaddr + phdr[i].p_memsz))
        {
            target_phdr = &phdr[i];
            break;
        }
    }

    if (target_phdr == NULL)
    {
        perror("Segment not found for faulting address");
        exit(EXIT_FAILURE);
    }

   
    void *virtual = mmap(vir_addr, page_size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0);
    if (virtual == MAP_FAILED)
    {
        perror("mmap");
        exit(EXIT_FAILURE);
    }


    lseek(fd, target_phdr->p_offset, SEEK_SET);
    if (read(fd, virtual, target_phdr->p_filesz) != target_phdr->p_filesz)
    {
        perror("read");
        exit(EXIT_FAILURE);
    }

    pagefault_occurred_count++;
    used+=target_phdr->p_memsz;
    lost += (page_size - target_phdr->p_memsz) / 1024.0;
}
void loader_cleanup(){
 
    free(ehdr);
    free(phdr);
    close(fd);
}

void load_and_run_elf(char **exe)
{
    // signal();
    fd = open(exe[1], O_RDONLY);

    if (fd == -1)
    {

        printf("Error opening ELF file");

        return;
    }

    ehdr = (Elf32_Ehdr *)malloc(sizeof(Elf32_Ehdr));

    if (read(fd, ehdr, sizeof(Elf32_Ehdr)) != sizeof(Elf32_Ehdr))
    {

        printf("Error reading ELF header");

        return;
    }

    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)
    {

        fprintf(stderr, "Invalid ELF file\n");

        return;
    }

    phdr = (Elf32_Phdr *)malloc(ehdr->e_phentsize * ehdr->e_phnum);

    lseek(fd, ehdr->e_phoff, SEEK_SET);

    if (read(fd, phdr, ehdr->e_phentsize * ehdr->e_phnum) !=

        ehdr->e_phentsize * ehdr->e_phnum)
    {

        printf("Error reading program header table");

        return;
    }
    struct sigaction sa;
    sa.sa_sigaction = page_fault_handler;
    sa.sa_flags = SA_NODEFER | SA_SIGINFO;
    sigaction(SIGSEGV, &sa, NULL);
    


        int (*_start)() = (int (*)())(uintptr_t)ehdr->e_entry;
        int result = _start();
        printf("%d\n",result);
        

       
    // 0x8049049
    // void *vir_adr = (void *)(uintptr_t)phdr[i].p_paddr;
    // printf("%p\n",vir_adr);
    
  
   
   
}


int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Usage: %s \n", argv[0]);
        exit(1);
    }

    page_size = sysconf(_SC_PAGESIZE);
    printf("Page size: %d bytes\n", page_size);
    

    load_and_run_elf(argv);
    
    

    printf("Number of page allocation: %d\n",pagefault_occurred_count);
    printf("Number of page faults: %d\n",pagefault_occurred_count);
    printf("Internal Fragmentation: %.3f KB\n",lost);
    printf("Used Memory: %.3f KB\n",used);


    loader_cleanup();

    return 0;
}
