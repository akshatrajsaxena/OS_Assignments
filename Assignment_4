#include "loader.h"

Elf32_Ehdr *ehdr;

Elf32_Phdr *phdr;

int fd;


static  int pagefault_occurred_count = 0;
double used,lost;
long page_size;
__pid_t child_1;
static volatile int  kill_c=1;
volatile int index_seg;
sem_t _semaphore;

void pagefault_handler(int signo, siginfo_t *info, void *context) {
    void* fault_address = info->si_addr;
    printf("Segmentation fault at address: %p\n", fault_address);
    page_allocator(fault_address);
    
}

void page_allocator(void* address){
    
    for (int i = 0; i < ehdr->e_phnum; i++)
    {  
        
    
    void *vir_adr = (void *)(uintptr_t)phdr[i].p_vaddr;
    //checking if the 
    if((address)>=(vir_adr)&&(vir_adr+phdr[i].p_memsz)>address ){
    printf("Page Created\n");
    void *virtual = mmap(vir_adr, 2*page_size,

                                PROT_READ | PROT_WRITE | PROT_EXEC,

                                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
            pagefault_occurred_count++;
            lost+=(page_size-phdr[i].p_memsz);
            used+=phdr[i].p_memsz;

            if (virtual == MAP_FAILED)
            {

                printf("Error mapping memory\n");

                return;
            }

            lseek(fd, phdr[i].p_offset, SEEK_SET);

            if (read(fd, virtual, phdr[i].p_filesz) != phdr[i].p_filesz)
            {

                printf("Error reading segment content\n");

                return;
            }
            }
            
            }
            return;
}



void loader_cleanup()
{

    free(ehdr);

    free(phdr);

    if (fd >= 0)
    {

        close(fd);

        fd = -1;
    }
}

void load_and_run_elf(char **exe)
{
    // signal();
    fd = open(exe[1], O_RDONLY);

    if (fd == -1)
    {

        printf("Error opening ELF file");

        return;
    }

    ehdr = (Elf32_Ehdr *)malloc(sizeof(Elf32_Ehdr));

    if (read(fd, ehdr, sizeof(Elf32_Ehdr)) != sizeof(Elf32_Ehdr))
    {

        printf("Error reading ELF header");

        return;
    }

    if (memcmp(ehdr->e_ident, ELFMAG, SELFMAG) != 0)
    {

        fprintf(stderr, "Invalid ELF file\n");

        return;
    }

    phdr = (Elf32_Phdr *)malloc(ehdr->e_phentsize * ehdr->e_phnum);

    lseek(fd, ehdr->e_phoff, SEEK_SET);

    if (read(fd, phdr, ehdr->e_phentsize * ehdr->e_phnum) !=

        ehdr->e_phentsize * ehdr->e_phnum)
    {

        printf("Error reading program header table");

        return;
    }
    struct sigaction sa;
    sa.sa_sigaction = pagefault_handler;
    sa.sa_flags = SA_NODEFER | SA_SIGINFO;
    sigaction(SIGSEGV, &sa, NULL);
    
    for (int i = 0; i < ehdr->e_phnum; i++)
    { 


        int (*_start)() = (int (*)())(uintptr_t)ehdr->e_entry;
        int result = _start();
        printf("%d\n",result);
        break;

       
    // 0x8049049
    // void *vir_adr = (void *)(uintptr_t)phdr[i].p_paddr;
    // printf("%p\n",vir_adr);
    }
  
   
   
}

int main(int argc, char **argv)
{
   
    if (argc != 2)
    {
        printf("Usage: %s <ELF Executable>\n", argv[0]);
        exit(1);
    }


if (sem_init(&_semaphore, 0, 1) == -1) {
            perror("sem_init");
            return 1;
        }

    page_size = sysconf(_SC_PAGESIZE);
    printf("Page size: %ld bytes\n", page_size);
    

    load_and_run_elf(argv);
    
    

    printf("Number of page allocation: %d\n",pagefault_occurred_count);
    printf("Number of page faults: %d\n",pagefault_occurred_count);
    printf("Internal Fragmentation: %.3f KB\n",lost/(1024.0));
    printf("Used Memory: %.3f KB\n",used/(1024.0));


    loader_cleanup();
    
    
   

    return 0;
}
